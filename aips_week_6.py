# -*- coding: utf-8 -*-
"""AIPS Week 6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19wBQqoaq_hlj4f0zyEKTM7ySDqJAS3ie
"""

shapes = [
[0,0,0,0,0,0],
[1,1,0,0,1,0],
[1,0,0,2,0,2],
[0,0,2,0,0,0],
[2,0,0,0,0,0],
[0,0,0,1,1,0]
]

equal = [
[[4,3],[4,4]]
]

diffs = [
[[0,1],[0,2]],
[[1,1],[1,2]],
[[3,4],[3,5]]
]

class TangoProblem:

  def __init__(self, shapes, equals=[], diffs=[]):
    self.shapes = shapes
    self.equals = equals
    self.diffs = diffs

    #get formula
    self.str_clauses = self.makeStrClauses()
    self.varnames, self.clauses = self.convertToInts(self.str_clauses)

  def makeStrClauses(self):
      clauses =[]
      size = len(self.shapes)

      #r_c_s - row, column, shape (moon,sun)

      for r in range (size):
        for c in range(size): #each cell must have sun or moon set to true
          clauses.append((f'{r}_{c}_1', f'{r}_{c}_2'))
          for s in (1,2): #if this cell is set to s, set the other shape to false
            clauses.append((f'-{r}_{c}_{s}', f'-{r}_{c}_{3-s}'))

      for a,b in self.equals: # now deal with the inter-cell '=' operators
        for s in (1,2):
          clauses.append((f'-{a[0]}_{a[1]}_{s}',f'{b[0]}_{b[1]}_{s}'))
          clauses.append((f'{a[0]}_{a[1]}_{s}', f'-{b[0]}_{b[1]}_{s}'))

      # for (r1,c1),(r2,c2) in self.equals:
      #     for s in (1,2):
      #         # double implication, so enforce both ways
      #       clauses.append( (f'-{r1}_{c1}_{s}', f'{r2}_{c2}_{s}')  )
      #       clauses.append( (f'-{r2}_{c2}_{s}', f'{r1}_{c1}_{s}')  )


      for r in range(diffs): # now deal with the inter-cell 'x' operators
        for c in range(diffs):
          clauses.append(f'-{r}_{c}_{s}', f'-{r}_{c}_{3-s}')

      # for (r1,c1),(r2,c2) in self.diffs:
      #   for s in (1,2):
      #         # double implication, so enforce both ways
      #     clauses.append( (f'-{r1}_{c1}_{s}', f'-{r2}_{c2}_{s}')  )
      #     clauses.append( (f'-{r2}_{c2}_{s}', f'-{r1}_{c1}_{s}')  )

      for r in range(size):  # no more than two of the same shape together in any row
        for c in range(size-2):
            for s in (1,2):
              # for consecutive cells a, b, c we want (a /\ b) -> (¬c)
              # which is equivalent to ¬a \/ ¬b \/ ¬c
              clauses.append( (f'-{r}_{c}_{s}',f'-{r}_{c+1}_{s}',f'-{r}_{c+2}_{s}') )

     # exactly 3 of each shape per row
        for s in range(1,2):
            for r in range(size):
                # find all possible sets of 3 columns
                for (c1,c2,c3) in it.combinations(range(size),r=3):
                    others = [c for c in range(size) if c not in (c1,c2,c3)]
                    for co in others:
                        # we're saying (c1 /\ c2 /\ c3) -> (¬co), which is (¬c1 \/ ¬c2 \/ ¬c3 \/ ¬c4)
                        clauses.append( (f'-{r}_{c1}_{s}', f'-{r}_{c2}_{s}', f'-{r}_{c3}_{s}', f'-{r}_{co}_{s}') )

      # exactly 3 of each shape per column
        for s in range(1,2):
            for c in range(size):
                for (r1,r2,r3) in it.combinations(range(size),r=3):
                    others = [r for r in range(size) if r not in (r1,r2,r3)]
                    for ro in others:
                        clauses.append( (f'-{c}_{r1}_{s}', f'-{c}_{r2}_{s}', f'-{c}_{r3}_{s}', f'-{c}_{ro}_{s}') )

        return clauses

  def convertToInts(self, str_cl):
        """Convert clauses expressed as strings into lists of integers"""

        varnames2ints = {}
        clauses = []

        # go clause by clause
        for str_lits in str_cl:
            int_clause = []
            # take each literal in turn
            for str_lit in str_lits:
                is_neg = str_lit.startswith('-')
                justvar = str_lit[1:] if is_neg else str_lit
                var_int = varnames2ints.get(justvar,None)

                # if we haven't seen this variable name before, add it as the next integer
                if var_int == None:
                    var_int = len(varnames2ints)+1
                    varnames2ints[justvar] = var_int

                # now add it into the new clause, as negative int if it's a negative literal
                int_clause.append(var_int * (-1 if is_neg else 1) )
            clauses.append(int_clause)
        return varnames2ints, clauses

  def solve(self):
        """Attempt to find a solution using a SAT solver"""

        formula = CNF()
        for clause in self.clauses:
            formula.append(clause)

        with Glucose3(bootstrap_with=formula) as gluc:
            gluc.solve()
            model = gluc.get_model()
            logging.debug(f"Received model: {model}")
        return model

  def printSolution(self, model):
        """Pretty-print the board given a SAT model"""

        size = len(self.shapes)
        for r in range(size):
            shapes_in_row = []
            for c in range(size):
                # which of 1 or 2 is set to true in the model?
                is_1 = (self.varnames[f'{r}_{c}_1'] in model)
                is_2 = (self.varnames[f'{r}_{c}_2'] in model)
                if (is_1 and is_2):
                    logging.warning("Oops, we can't have both values true at {r}_{c}!")
                    shapes_in_row.append('X')
                elif not (is_1 or is_2):
                    logging.warning("Oops, we have no value set to true at {r}_{c}!")
                    shapes_in_row.append('-')
                else:
                    shapes_in_row.append('1' if is_1 else '2')
            print(' '.join(shapes_in_row))

  if __name__=='__main__':
    if len(sys.argv) < 2:
        print("Pass in the JSON file with the board")
        exit(1)
    # enable debug messages
    logging.basicConfig(level=logging.DEBUG)

    # read in the board data
    with open(sys.argv[1],'rt') as f:
        board = json.loads(f.read())
    logging.debug(f"Loaded board info: {board}")

    # create a TangoProblem instance with the existing shapes, the '=' pairs and the 'x' pairs
    tp = TangoProblem(board['shapes'], board.get('equal',[]), board.get('different',[]))

    # obtain a solution if possible, in terms of the boolean variables
    model = tp.solve()

    # interpret the SAT solver output
    tp.printSolution(model)

# Commented out IPython magic to ensure Python compatibility.
# uncomment below to install the module for IPython notebooks
# %pip install python-sat
from pysat.solvers import Glucose3
from pysat.formula import CNF
formula = CNF() # formula represents:
formula.append([ 1,-2, 3]) # (x1 \/ ¬x2 \/ x3) /\
formula.append([ 1, 2,-4]) # (x1 \/ x2 \/ ¬x4) /\
formula.append([ 2,-3,-4]) # etc...
formula.append([-1, 3,-4])
formula.append([ 1, 3, 4])

with Glucose3(bootstrap_with=formula) as solver:
  print(solver.solve())
  print(solver.get_model())