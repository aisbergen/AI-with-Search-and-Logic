# -*- coding: utf-8 -*-
"""SR Week 7 & Week 8

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mnkcSqxsFlmEKkDOIcwVzDiMY0H1_uX1

Run the following code to set up the Savile Row environment and define a function for running Savile Row.
"""

import os

srurl="https://www-users.york.ac.uk/peter.nightingale/savilerow/savilerow-1.10.1-linux.tgz"
srdir="savilerow-1.10.1-linux"
![ ! -d $srdir ] && wget $srurl && tar -zxf savilerow-1.10.1-linux.tgz
stub=f"./{srdir}/savilerow -minion-bin {srdir}/bin/minion -satsolver-bin {srdir}/bin/kissat"

def solve(model, param):
  with open("tmp.eprime", "wt") as f:
    f.write(model)
  with open("tmp.param", "wt") as f:
    f.write(param)
  !$stub tmp.eprime tmp.param -run-solver

  try:
    with open("tmp.param.solution", "rt") as f:
      sol=f.read()
    os.remove("tmp.param.solution")
  except FileNotFoundError:
    sol="No solution found."
  print(sol)

"""## **Week 7 Lab**"""

#Forced assign
model = """
language ESSENCE' 1.0
$ The Crystal Maze Puzzle
letting Dom be domain int(1..8)
find x1,x2,x3,x4,x5,x6,x7,x8 : Dom

such that
x1 = 1,

|x1-x2| > 1,
|x1-x3| > 1,
|x1-x4| > 1,
|x1-x5| > 1,
|x2-x4| > 1,
|x2-x5| > 1,
|x2-x6| > 1,
|x3-x4| > 1,
|x3-x7| > 1,
|x4-x5| > 1,
|x4-x7| > 1,
|x4-x8| > 1,
|x5-x6| > 1,
|x5-x7| > 1,
|x5-x8| > 1,
|x6-x8| > 1,
|x7-x8| > 1,

allDiff([x1,x2,x3,x4,x5,x6,x7,x8])


"""
param = """
language ESSENCE' 1.0





"""

solve(model, param)

#Graph parameterized
model = """
$ The Crystal Maze Puzzle

language ESSENCE' 1.0

$ We are fixing the nodes
letting Dom be domain int(1..8)

$ But parameterising on the edges
$ The edges are represented as pairs of integers [i,j]
$  where are i and j are node indices. The edges matrix contains numEdges such pairs
given edges: matrix indexed by[int(1..numEdges), int(1..2)] of int

$ An easy way to get hold of the variables by their names is to put them into an array:
find nodes: matrix indexed by[int(1..8)] of Dom

such that

forAll edge : int(1..numEdges) .
  |nodes[edges[edge,1]] - nodes[edges[edge,2]]| > 1,

allDiff(nodes)

"""
param = """
language ESSENCE' 1.0
letting edges be [[1,2],
                  [1,3],
                  [1,4],
                  [1,5],
                  [2,4],
                  [2,5],
                  [2,6],
                  [3,4],
                  [3,7],
                  [4,5],
                  [4,7],
                  [4,8],
                  [5,6],
                  [5,7],
                  [5,8],
                  [6,8],
                  [7,8]]
"""

solve(model, param)

#Fully parameterized
model = """
language ESSENCE' 1.0

$ The Crystal Maze Puzzle
$ We are fixing the nodes

given noNodes: int

$ But parameterising on the edges
$ The edges are represented as pairs of integers [i,j]
$  where are i and j are node indices. The edges matrix contains numEdges such pairs
given edges: matrix indexed by[int(1..numEdges), int(1..2)] of int

$ An easy way to get hold of the variables by their names is to put them into an array:
find nodes: matrix indexed by[int(1..noNodes)] of int(1..noNodes)

such that

forAll edge : int(1..numEdges) .
  |nodes[edges[edge,1]] - nodes[edges[edge,2]]| > 1,

allDiff(nodes)


"""
param = """
letting noNodes be 8
letting edges be [[1,2],
                  [1,3],
                  [1,4],
                  [1,5],
                  [2,4],
                  [2,5],
                  [2,6],
                  [3,4],
                  [3,7],
                  [4,5],
                  [4,7],
                  [4,8],
                  [5,6],
                  [5,7],
                  [5,8],
                  [6,8],
                  [7,8]]
"""

solve(model, param)

#Two solutions
model = """
language ESSENCE' 1.0

$ The Crystal Maze Puzzle
$ We are fixing the nodes
given noNodes: int

$ But parameterising on the edges
$ The edges are represented as pairs of integers [i,j]
$  where are i and j are node indices. The edges matrix contains numEdges such pairs
given edges: matrix indexed by[int(1..numEdges), int(1..2)] of int

$ An easy way to get hold of the variables by their names is to put them into an array:
find nodes: matrix indexed by[int(1..noNodes)] of int(1..noNodes)

such that

forAll edge : int(1..numEdges) .
  |nodes[edges[edge,1]] - nodes[edges[edge,2]]| > 1,

allDiff(nodes)


"""
param = """
language ESSENCE' 1.0

letting noNodes be 4
letting edges be [[1,2],[1,3],[2,4]]
"""

solve(model, param)

"""WEEK 8 LAB"""

model = """
language ESSENCE' 1.0
letting   RANGE be domain int(1..9)
letting   VALUES be domain int(0..9)

given     values : matrix indexed by [RANGE,RANGE] of VALUES

find      field: matrix indexed by [RANGE, RANGE] of RANGE

such that
  $ all rows have to be different
  forAll row : RANGE .
      allDiff(field[row,..]),

  $ all columns have to be different
  forAll col : RANGE .
      allDiff(field[..,col]),

  $ all 3x3 blocks have to be different
  $ i, j are the coordinates of the upper-left corner of the 3x3 block.
  $forAll i,j : int(1,4,7) .
  $    forAll row1, row2 : int(i..i+2) .
  $        forAll col1, col2 : int(j..j+2) .
  $            ((col1 != col2) \/ (row1 != row2)) ->
  $                field[row1, col1] != field[row2, col2],

  forAll i,j : int(1,4,7) .
    allDiff([ field[k,l] | k : int(i..i+2), l : int(j..j+2)]),


  $ Set some initial values
  forAll row,col : RANGE .
      (values[row,col] > 0) ->
          (field[row,col] = values[row,col])"""


param = """
language ESSENCE' 1.0
letting values be [ [ 5, 3, 0, 0, 7, 0, 0, 0 ,0 ],
                    [ 6, 0, 0, 1, 9, 5, 0, 0, 0 ],
                    [ 0, 9, 8, 0, 0, 0, 0, 6, 0 ],
                    [ 8, 0, 0, 0, 6, 0, 0, 0, 3 ],
                    [ 4, 0, 0, 8, 0, 3, 0, 0, 1 ],
                    [ 7, 0, 0, 0, 2, 0, 0, 0, 6 ],
                    [ 0, 6, 0, 0, 0, 0, 2, 8, 0 ],
                    [ 0, 0, 0, 4, 1, 9, 0, 0, 5 ],
                    [ 0, 0, 0, 0, 8, 0, 0, 7, 9 ]]
"""


solve(model, param)

#Modelling Winner Determination Problem (Combinatorial Auction)
model = """
language ESSENCE' 1.0

given nItems : int(1..)
given nBids : int(1..)

$  For each bid b, price[b] is the amount of money offered.
given price : matrix indexed by [int(1..nBids)] of int(0..)

$  For each bid b, bids[b, ..] is the occurrence representation of the set of items.
given bids : matrix indexed by [int(1..nBids), int(1..nItems)] of bool

$  Occurrence representation of the set of accepted bids.
find accepted : matrix indexed by [int(1..nBids)] of bool

maximising sum([ price[i]*accepted[i] | i : int(1..nBids) ])

$ Alternative with sum quantifier instead of a comprehension:
$maximising sum i : int(1..nBids) . price[i]*accepted[i]

such that

forAll i : int(1..nBids).
  forAll j : int(1..nBids) .
    i<j ->
      (
        (sum k : int(1..nItems). (bids[i,k] /\ bids[j,k]) )!=0 ->
            !(accepted[i] /\ accepted[j])
        $ Alternative with exists instead of sum:
        $(exists k : int(1..nItems). (bids[i,k] /\ bids[j,k]) ) ->
        $   !(accepted[i] /\ accepted[j])
      )


"""
param = """
language ESSENCE' 1.0

letting nItems = 4
letting nBids = 4

letting price = [10,12,13,20]

letting bids=
[[true,true,false,true],
[false, false, true, false],
[true, false, false, true],
[true, true, true, true]]
"""

solve(model, param)


model = """
language ESSENCE' 1.0

given t:int

find  actions : matrix indexed by [int(1..t)] of int(1..4) $pick_up,move, put down,go back
find robot_location: matrix indexed by [int(1..t)] of int(0..1) $which room robot is in
find balls_room: matrix indexed by [int(1..t), int(1..4)] of int(0..1) $balls in room 0 and 1
find robot_balls: matrix indexed by [int(1..t), int(1..4)] of int(0..1) $balls in robot hand

such that

$pick up, put down, move

$1 action at a time
$when robot moves he can't pick up/put down
$
forAll i : int(1..t) . $1 action at a time

  actions[i]=1, $pick up


    $but no more 2 balls for robot hand
    forAll i,j : robot_balls .  $but no more 2 balls for robot hand
      sum([ toInt(robot_balls[i,j]) | j : int(1..4)]) <= 2

    forAll i : int(1..t-1) .
    forAll j : int(1..4) .
      balls_room[i+2, j] = balls_room[i, j] - toInt(robot_balls[i, j]) $reduces balls in room 1


  actions[i]=2, $move to room 1
    $when robot moves he can't pick up/put down

    forAll location : int(0..1) .
      robot_location=1

  actions[i]=3, $put down
   forAll i : int(1..t), j : int(1..4) .
    robot_balls[i,j] = 0
    forAll i,j : robot_balls .
      sum([ toInt(robot_balls[i,j]) | j : int(1..4)]) <= 0 $dropping balls
      balls_room[i,j] = balls_room[i+2,j] - toInt(robot_balls[i,j])

  actions[i]=4, $move, go back to room 0
    $when robot moves he can't pick up/put down
    forAll location : int(0..1) .
      robot_location=0

  forAll i : int(1..t) .
  (actions[i] = 2 \/ actions[i] = 4) ->
    (sum([robot_balls[i,j] | j : int(1..4)]) = sum([robot_balls[i-1,j] | j : int(1..4)]))


  sum([ toInt(actions[i] = 1) * toInt(robot_balls[i,j] = 1) | j : int(1..4)]) <= 2 $no more than 2 balls in robot hand

(actions[i]=2 \/ actions[i]=4) -> $When Robot Moves, Cannot Pick or Drop
  (
    forAll j : int(1..4) .
      robot_balls[i,j]=robot_balls[i-1,j]
  )


forAll i : int(1..t) . $"If the action at step i is pick-up, then robot must be in room 0."
    (actions[i] = 1) -> (robot_location[i] = 0)






"""
param = """
language ESSENCE' 1.0

letting t = 100

solve(model, param)
