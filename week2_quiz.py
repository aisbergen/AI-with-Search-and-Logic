# -*- coding: utf-8 -*-
"""Week2_quiz.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jdz2R3fESmrBnmXwTSxU6BcZxjKnmrwd
"""

# Node names
p_names = [c for c in 'ABCDEFGH']
print(f"Our places are called:\n{p_names}")

# Straight-line distances (heuristics) from each node to the goal (H)
sld_dists = {
    'A': 5, 'B': 6, 'C': 8, 'D': 4, 'E': 4, 'F': 5, 'G': 2, 'H': 0
}

# The paths in the graph (node_a, node_b, walking_distance)
paths = [
    ('A', 'B', 3), ('A', 'C', 3),
    ('B', 'D', 2), ('C', 'F', 3),
    ('D', 'E', 4), ('E', 'F', 1),
    ('F', 'G', 3), ('G', 'H', 2),
    ('E', 'G', 2)
]

# Elevations of the places A to H
elevations = {
    'A': 5, 'B': 6, 'C': 8, 'D': 4, 'E': 4, 'F': 5, 'G': 2, 'H': 0
}

print("Straight-line distances (SLD):", sld_dists)
print("Paths:", paths)
print("Elevations:", elevations)

import networkx as nx

# some useful maths, especially for arrays and matrices
import numpy as np

import networkx as nx
import matplotlib.pyplot as plt

g = nx.Graph()  # Create an empty undirected graph

# Ensure node names match their correct elevation
p_names = [c for c in 'ABCDEFGH']
n_places = len(p_names)  # Ensure correct length

# Add nodes to the graph with correct labels
for name in p_names:  # Loop over node names directly
    g.add_node(name, name=name, elevation=elevations[name])  # Use name as key

# Now add edges where paths exist
for (u, v, d) in paths:
    g.add_edge(u, v, distance=d)

# Generate positions for nodes
_pos = nx.kamada_kawai_layout(g)

# Create labels using the correct node names
_node_labels = {name: f"{name}\n({elevations[name]})" for name in p_names}

# Draw the graph
plt.figure(figsize=(8, 6))
nx.draw_networkx(
    g, with_labels=True, labels=_node_labels, pos=_pos,
    node_shape='o', node_size=900, node_color="#ddddff", font_size=10
)
nx.draw_networkx_edge_labels(
    g, pos=_pos,
    edge_labels={(u, v): d for (u, v, d) in paths}
)

plt.show()  # Ensure the graph displays

def neighbours(node):
    neighbour_list = []

    for node_a, node_b, distance in paths:
        if node == node_a:
            elevation_change = elevations[node_b] - elevations[node_a]
            neighbour_list.append((node_b, distance, elevation_change))
        elif node == node_b:
            elevation_change = elevations[node_a] - elevations[node_b]
            neighbour_list.append((node_a, distance, elevation_change))

    return neighbour_list

# Testing neighbors function
print("Neighbors of D:", neighbours('D'))
print("Neighbors of F:", neighbours('F'))

def depth_limited_search(node, goal, depth, path):
  if node == goal:
    return path + [node]

  if depth ==0:
    return "CUTOFF" #reached limit

  cutoff_occurred = False

  for neighbour, _, _ in neighbours(node):  #explore neighbors
     if neighbour not in path:  # Avoid cycles
          result = depth_limited_search(neighbour, goal, depth - 1, path + [node])

          if result == "CUTOFF":
                cutoff_occurred = True  # We hit the depth limit, so retry at higher depth
          elif result is not None:
                return result

  return "CUTOFF" if cutoff_occurred else None

path = depth_limited_search('A','H', 2, [])
print("Shortest Path:", path)